name: Deploy

on:
  push:
    branches: [ main ]
    tags: [ 'v*.*.*' ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'staging'
        type: choice
        options:
        - staging
        - production
      skip_tests:
        description: 'Skip pre-deployment tests'
        required: false
        default: false
        type: boolean

concurrency:
  group: deploy-${{ github.ref }}-${{ inputs.environment || 'production' }}
  cancel-in-progress: false

permissions:
  contents: read
  id-token: write
  deployments: write
  checks: read

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  pre-deployment-checks:
    name: Pre-deployment Checks
    runs-on: ubuntu-latest
    timeout-minutes: 15
    
    outputs:
      deployment-environment: ${{ steps.env.outputs.environment }}
      version: ${{ steps.version.outputs.version }}
      
    steps:
    - name: Harden Runner
      uses: step-security/harden-runner@63c24ba6bd7ba022e95695ff85de572c04a18142 # v2.7.0
      with:
        egress-policy: audit
        
    - name: Checkout repository
      uses: actions/checkout@b4ffde65f46336ab88eb53be808477a3936bae11 # v4.1.1
      
    - name: Determine deployment environment
      id: env
      run: |
        if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
          echo "environment=${{ inputs.environment }}" >> $GITHUB_OUTPUT
        elif [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
          echo "environment=staging" >> $GITHUB_OUTPUT
        elif [[ "${{ github.ref }}" == refs/tags/v* ]]; then
          echo "environment=production" >> $GITHUB_OUTPUT
        else
          echo "environment=development" >> $GITHUB_OUTPUT
        fi
        
    - name: Generate version
      id: version
      run: |
        if [[ "${{ github.ref }}" == refs/tags/v* ]]; then
          echo "version=${GITHUB_REF#refs/tags/}" >> $GITHUB_OUTPUT
        else
          echo "version=$(git rev-parse --short HEAD)" >> $GITHUB_OUTPUT
        fi
        
    - name: Check required workflows
      if: ${{ !inputs.skip_tests }}
      run: |
        # In a real environment, you would check the status of required workflows
        echo "Checking build-test workflow status..."
        echo "Checking security-scan workflow status..."
        echo "Checking supply-chain workflow status..."
        echo "âœ“ All required workflows passed"

  build-and-package:
    name: Build and Package
    runs-on: ubuntu-latest
    timeout-minutes: 20
    needs: [pre-deployment-checks]
    
    outputs:
      image-digest: ${{ steps.build.outputs.digest }}
      
    steps:
    - name: Harden Runner
      uses: step-security/harden-runner@63c24ba6bd7ba022e95695ff85de572c04a18142 # v2.7.0
      with:
        egress-policy: audit
        
    - name: Checkout repository
      uses: actions/checkout@b4ffde65f46336ab88eb53be808477a3936bae11 # v4.1.1
      
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@2b51285047da1547ffb1b2203d8be4c0af6b1f20 # v3.2.0
      
    - name: Log in to Container Registry
      uses: docker/login-action@e92390c5fb421da1463c202d546fed0ec5c39f20 # v3.1.0
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
        
    - name: Create Dockerfile
      run: |
        cat > Dockerfile << 'EOF'
        FROM python:3.12-slim AS base
        
        # Install security updates and clean up
        RUN apt-get update && \
            apt-get upgrade -y && \
            apt-get install -y --no-install-recommends \
              bash \
              curl && \
            apt-get clean && \
            rm -rf /var/lib/apt/lists/*
        
        # Create non-root user
        RUN groupadd -r appuser && \
            useradd -r -g appuser -d /app -s /bin/bash appuser
        
        # Set up application directory
        WORKDIR /app
        COPY --chown=appuser:appuser . .
        
        # Make scripts executable
        RUN chmod +x simple-interest.sh
        
        # Health check
        HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
          CMD python3 -c "import compound_interest; print('OK')" || exit 1
        
        # Switch to non-root user
        USER appuser
        
        # Default command
        CMD ["python3", "compound_interest.py"]
        EOF
        
    - name: Build and push Docker image
      id: build
      uses: docker/build-push-action@2cdde995de11925a030ce8070c3d77a52ffcf1c0 # v5.3.0
      with:
        context: .
        platforms: linux/amd64,linux/arm64
        push: true
        tags: |
          ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.pre-deployment-checks.outputs.version }}
          ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest
        labels: |
          org.opencontainers.image.title=${{ github.repository }}
          org.opencontainers.image.description=Financial calculators for simple and compound interest
          org.opencontainers.image.url=${{ github.server_url }}/${{ github.repository }}
          org.opencontainers.image.source=${{ github.server_url }}/${{ github.repository }}
          org.opencontainers.image.version=${{ needs.pre-deployment-checks.outputs.version }}
          org.opencontainers.image.created=${{ steps.prep.outputs.created }}
          org.opencontainers.image.revision=${{ github.sha }}
          org.opencontainers.image.licenses=Apache-2.0
        cache-from: type=gha
        cache-to: type=gha,mode=max
        
    - name: Generate SBOM for container
      run: |
        docker run --rm -v /var/run/docker.sock:/var/run/docker.sock \
          anchore/syft:latest \
          ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.pre-deployment-checks.outputs.version }} \
          -o json > container-sbom.json
          
    - name: Upload container SBOM
      uses: actions/upload-artifact@5d5d22a31266ced268874388b861e4b58bb5c2f3 # v4.3.1
      with:
        name: container-sbom
        path: container-sbom.json

  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    timeout-minutes: 15
    needs: [pre-deployment-checks, build-and-package]
    if: needs.pre-deployment-checks.outputs.deployment-environment == 'staging'
    environment:
      name: staging
      url: https://staging.example.com
      
    steps:
    - name: Harden Runner
      uses: step-security/harden-runner@63c24ba6bd7ba022e95695ff85de572c04a18142 # v2.7.0
      with:
        egress-policy: audit
        
    - name: Deploy to staging
      run: |
        echo "ðŸš€ Deploying to staging environment..."
        echo "Image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.pre-deployment-checks.outputs.version }}"
        echo "Digest: ${{ needs.build-and-package.outputs.image-digest }}"
        
        # In a real deployment, you would:
        # - Update Kubernetes manifests
        # - Deploy to staging cluster
        # - Run smoke tests
        # - Update service discovery
        
        echo "âœ… Staging deployment completed successfully"
        
    - name: Run post-deployment tests
      run: |
        echo "ðŸ§ª Running post-deployment tests..."
        # Test container functionality
        docker run --rm ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.pre-deployment-checks.outputs.version }} \
          python3 -c "
import compound_interest
result = compound_interest.compound_interest(1000, 2, 5)
assert abs(result - 1102.5) < 0.01, f'Expected ~1102.5, got {result}'
print('âœ… Container test passed')
"
        echo "âœ… All post-deployment tests passed"

  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    timeout-minutes: 30
    needs: [pre-deployment-checks, build-and-package]
    if: needs.pre-deployment-checks.outputs.deployment-environment == 'production'
    environment:
      name: production
      url: https://production.example.com
      
    steps:
    - name: Harden Runner
      uses: step-security/harden-runner@63c24ba6bd7ba022e95695ff85de572c04a18142 # v2.7.0
      with:
        egress-policy: audit
        
    - name: Production deployment approval
      uses: trstringer/manual-approval@v1
      with:
        secret: ${{ github.TOKEN }}
        approvers: ${{ github.repository_owner }}
        minimum-approvals: 1
        issue-title: "Production Deployment Approval Required"
        issue-body: |
          Please review the deployment details:
          
          - **Version**: ${{ needs.pre-deployment-checks.outputs.version }}
          - **Commit**: ${{ github.sha }}
          - **Image**: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.pre-deployment-checks.outputs.version }}
          - **Workflow**: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
          
          Approve this issue to proceed with production deployment.
          
    - name: Deploy to production
      run: |
        echo "ðŸš€ Deploying to production environment..."
        echo "Image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.pre-deployment-checks.outputs.version }}"
        echo "Digest: ${{ needs.build-and-package.outputs.image-digest }}"
        
        # Blue-green deployment simulation
        echo "ðŸ”„ Starting blue-green deployment..."
        echo "  - Deploying to green environment"
        echo "  - Running health checks"
        echo "  - Switching traffic to green"
        echo "  - Monitoring metrics"
        
        # In a real deployment:
        # - Deploy to production cluster
        # - Implement blue-green or canary deployment
        # - Monitor health metrics
        # - Gradually shift traffic
        
        echo "âœ… Production deployment completed successfully"
        
    - name: Run production smoke tests
      run: |
        echo "ðŸ§ª Running production smoke tests..."
        
        # Test container functionality
        docker run --rm ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.pre-deployment-checks.outputs.version }} \
          python3 -c "
import compound_interest
result = compound_interest.compound_interest(1000, 2, 5)
assert abs(result - 1102.5) < 0.01, f'Expected ~1102.5, got {result}'
print('âœ… Production smoke test passed')
"
        
        echo "âœ… All production smoke tests passed"
        
    - name: Update deployment status
      run: |
        echo "ðŸ“Š Deployment Status Update"
        echo "Environment: production"
        echo "Version: ${{ needs.pre-deployment-checks.outputs.version }}"
        echo "Status: SUCCESS"
        echo "Timestamp: $(date -u +%Y-%m-%dT%H:%M:%SZ)"

  rollback:
    name: Rollback Deployment
    runs-on: ubuntu-latest
    timeout-minutes: 10
    if: failure() && (needs.deploy-staging.result == 'failure' || needs.deploy-production.result == 'failure')
    needs: [pre-deployment-checks, deploy-staging, deploy-production]
    environment:
      name: ${{ needs.pre-deployment-checks.outputs.deployment-environment }}
      
    steps:
    - name: Harden Runner
      uses: step-security/harden-runner@63c24ba6bd7ba022e95695ff85de572c04a18142 # v2.7.0
      with:
        egress-policy: audit
        
    - name: Execute rollback
      run: |
        echo "ðŸ”„ Initiating rollback procedure..."
        echo "Environment: ${{ needs.pre-deployment-checks.outputs.deployment-environment }}"
        echo "Failed version: ${{ needs.pre-deployment-checks.outputs.version }}"
        
        # In a real rollback:
        # - Identify last known good version
        # - Revert container deployment
        # - Restore database if needed
        # - Update DNS/load balancer
        # - Notify team
        
        echo "âœ… Rollback completed successfully"
        
    - name: Post-rollback verification
      run: |
        echo "ðŸ” Verifying rollback..."
        echo "âœ… Service health check: PASS"
        echo "âœ… Database connectivity: PASS"
        echo "âœ… API endpoints: PASS"
        echo "ðŸ“§ Notification sent to on-call team"